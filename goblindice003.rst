Unlimited damage
================

about
-----

This page demonstrate some more sophisticated random functions to model a more detailed combat model and introduce the use of a recursion. Also shows how to organize functions in a module and access them from other python programs to provide output inside an :term:`GUI` Graphical user interface.


.. note:: Please help improving this tutorial!
   
   Do you found a typo or failure ? Do you have ideas to improve this tutorial? Please edit/comment this file directly at https://github.com/horstjens/ThePythonGameBook/blob/master/goblindice003.rst (you need an account at github.com to do so).


idea
----

Allow unlimited damage by using the *recursive* ``re_roll`` function that can call itself. Also, packing the whole combat calculating inside a ``strike`` function that can either produce text ouptut or returns a text string to an external python program to be displayed inside a scrollbox GUI widget. 

.. figure:: /python/goblindice/goblindice003.png
   :alt: Flow Chart for goblindice001
   :height: 800px
    
 
less boring combat
------------------   

By using ``random.randint()`` to calculate the attack and defense values, the outcome is limited to a finite number of possibilites. In the pen-and-paper era, a dice throw using a 20-sided die can simulate 20 different outcomes. But does a real fighter has only 20 different ways to act ? Using the calculating power of a computer, it's easy to simulate an (near) infinte numbers of possible outcomes by using -for example- the ``random.random()`` function instead of ``random.randint()``:

.. code-block:: python
   attack = random.random()

``Random.random()`` generates a random float (decimal point) number bewteen 0.0 and 1.0, like 0.423156879. While `precision` or number of post decimal positions is not infinite but depends of your computers CPU power, it is high in practice high enough to simulate endless different outcomes. The *distribution* of numbers generated by ``random.random`` is equal: The probability to make an extreme powerful attack (like >0.9) is the same as the probability to make an extreme unsuccessful attack (like <0.1).


.. figure:: /python/goblindice/attack-values.png
   :alt: attack values generated by random.random()
   :align: right
   
To the right is a graphic (generated with :ref:``csvmaker.py`` and openoffice) that shows the distribution of 1000 attack values generated with the``random.random())`` function. While all values are between 0.0 and 1.0, there is no clear prediction possible about an `most popular`number. Note that to save place on the x-axis, all values are grouped at the second decimal position. If a million attack values would be calculated instead of just 1000, the bars would have more equal hight.
   

Another fine effect of using floats instead of integers is that you can read the output generated by ``random.random()`` direct as an probabilty or percent chance: an attack score of 0.5 means a "fair" chance of 50% to hit an opponent, while an attack score of 0.99 means "perfect" chance (99%).

To simulate differnt attack skill of players, simply a player's  `base attack skill` to the `random.random()` value, much like in the previous examples:

.. code-block:: python

   # add a random float from 0.0 to 1.0 to the attack value
   attack = base_attack + random.random() 
   

   
more sophisticated combat rules
-------------------------------

.. figure:: /python/goblindice/standard_deviation.png
   :alt: standard deviation (wikipedia)
   :align: right
   
Even better than ``random.random()`` is the ``random.gauss()`` function: Generating float values like ``random.random()``, the gauss function requires two arguments: ``m`` and ``s``. The first argument, ``m`` (greek letter: mu ) is the median or the `middle` value while ``s`` (greek letter: sigma) is the standard deviation: how far the random values are distanced from ``m`` `on average`. Wikipedia explains it best:

At the graphic (right) dark blue is one standard deviation on either side of the mean. For the normal distribution, this accounts for 68.27 percent of the set; while two standard deviations from the mean (medium and dark blue) account for 95.45 percent; three standard deviations (light, medium, and dark blue) account for 99.73 percent; and four standard deviations account for 99.994 percent. The two points of the curve that are one standard deviation from the mean are also the inflection points.

This *normal distribution* or *Gaussian distribution* of values is often observed in nature, and there is no reason not to model a medieval fantasy combat simulation using ``random.gauss()``to produce as realistic values as possible. 

In this example, ``random.gauss(0.5,0.2)`` is used to model the defence values:

.. code-block:: python
   
   # add a random float ( 0.5 +- something) to the defense value
   defense = base_defense + random.gauss(0.5,0.2) 
   
.. figure:: /python/goblindice/defense-values.png
   :alt: defense values generated by random.gauss(0.5,0.2)
   :align: right

Different defense skill could be simulated by different base_defense values as well as by differnt values for mu (the higher, the better). An experinced fighter would also have a lower sigma, reflecting that he is able to defend with the same level of quality each time, without wide variation. Note that it is possible to produce negative defense values and values higher than 1:
   
At the right is a graphic (generated with :ref:``csvmaker.py`` and openoffice) that shows the distribution of 1000 defense values generated with the ``random.gauss(0.5,0.2))`` function. Most -but not all!- values are between 0.0 and 1.0. Unlike the attack values, here is a clear prediction possible about a `most popular`number: it's (around) 0.5, the mean or mu value. Note that to save place on the x-axis, all values are grouped at the second decimal position. If a million attack values would be calculated instead of just 1000, the bars resemble more a perfect Gaussian distribution.
   
dice throw with re-roll
-----------------------

It is no big deal for a combat sim to produce sometimes negative attack or defense values (simulating a very unlucky attack) by using the ``random.gauss()`` function. Not so for the damage calculation: A negative damage would mean that an opponent get more hitpoints if he is hit! 

One way to make sure that the ``random.gauss()`` function returns only useful values is to pack it inside an ``if elif else`` construct or using the in-built min() and max() functions of python:

.. code-block:: python

   def limited_gauss(m=0.5, s=0.2, upper_limit = 1.0, lower_limit=0):
       """returns an gauss random value inside limits"""
       gauss_value = random.gauss(m,s)
       return min(upper_limit, max(gauss_value,lower_limit))
       

.. figure:: /python/goblindice/damage-values.png
   :alt: defense values generated by random.gauss(0.5,0.2)
   :align: right

If you prefer to use integers instead of floats for damage calculation take a look at this *recursive* ``re_roll()`` function below to calculate unlimited damage. It simulates throwing dice with the rule that if the highest possible number (a 6 on a six-sided die) is rolled, 1 is subtracted from the actual rolled (6-1=5) number and a re-roll is allowed and it's number is added. If the second (re-roll) throw is also a 6, this procedere is repeated: 6-1 + 6-1 + 6-1 .... + 3. The -1 rule is added so that it becomes possible to roll a natural 6: 6-1 + 1 = 6. Witout this rule and simple rerolling, only 5 and 7 would be possible, but never 6. The re_roll function can deliver very high numbers with a very low probability. See this graphic of 1000 damage values calculated using ``re_roll(6)``:

This is a function that can call itself, a **recursive** function or :term:`recursion`. Keep in mind that a bad programmed recursion can become an endless loop (the computer "hangs") and that the maximum number of "recursion depth" is depended on the main memory of the computer.

Here is the code:

.. code-block:: python

   def re_roll(faces=6, start=0):
       """open ended die throw, can re-roll at highest face)"""
       while True: 
          roll = random.randint(1, faces)
          if roll != faces:
             return roll + start 
          return re_roll(faces, roll-1+start )

In the flow-chart above, the recursion is symbolized by the dashed arcs pointing from the end of the re_roll function to it's top. A function that calls itself and return it's return values to itself, to be used as parameters - for itself.
 




Code
====

This code consist of 2 seperate code blocks. 


prerequesites
-------------

  * necessary:
  
    * python3 is installed
    * both files are in the same folder
    * tkinter is correctly installed (usually automatic togehter with python or idle)
    
  * recommended:
  
    * python-friendly IDE like IDLE, Geany etc.
    
source code
-----------  

The ``goblindice003.py`` can run stand-alone but will only produce text ouput:
   
.. literalinclude:: /python/goblindice/goblindice003.py
   :language: python
   :linenos:

example output::

    *** Round: 28 *** Grunty has 3 hitpoints, Stinky has 67 hitpoints
    Smack! Stinky hits Grunty with a most skilled attack: 1.64>1.33
    ...and inflicts 2 damage!
    Smack! Grunty hits Stinky with a most skilled attack: 1.37>0.20
    ...and inflicts 6 damage!
    *** Round: 29 *** Grunty has 1 hitpoints, Stinky has 61 hitpoints
    Oh no! Stinky does not even hit Grunty 0.96 < 1.40
    Oh no! Grunty does not even hit Stinky 0.59 < 0.87
    *** Round: 30 *** Grunty has 1 hitpoints, Stinky has 61 hitpoints
    Smack! Stinky hits Grunty with a most skilled attack: 1.79>1.48
    ...and inflicts 4 damage!
    - - - - - - - - - - - - - - - - - - - - 
    Victory for Stinky after 30 rounds


This small python program displays the text output of ``goblindice003.py`` inside a cute, scrollable text widget:

.. literalinclude:: /python/goblindice/scrollbox.py
   :language: python
   :linenos:

example output:

.. figure:: /python/goblindice/scrollbox.png
   :alt: scrollbox output
   :align: left





code discussion
---------------


not yet written
